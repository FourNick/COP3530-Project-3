#include <iostream>
#include <vector>
#include <string>

using namespace std;

// When load factor is reached, then rehash the keys by using modulo and 2 * tableSize
// so if max load factor = 0.8 and it reaches 0.8, rehash and then load factor is now 0.4
// max stays at 0.8

struct NGO{
    unsigned int income;
    string name;
    int EIN;
    string zip;
    string address;
    string state;
    NGO* next;
    vector<NGO> NGOobj;

public:
    //NGO(unsigned int income, string name, int EIN, string zip, string address, string state);

};




class HashMap{
private:

    unsigned int tableSize = 0;
    //static const unsigned int tableSize = 1000000;
    unsigned int twSize = 10000;
    unsigned int realSize;
    float maxLoadFactor = 0.75; // should not reach this.
    float elementCount = 0;
    float currLoadFactor = 0; // # of elements / # bucket count ---- buckets = tableSize
    //vector<NGO> NGOvec;

    /*
    Data::Data(string state, int pcIncome, int pop, int mhIncome, int numOfHH)
{
    this->state = state;
    this->pcIncome = pcIncome;
    this->pop = pop;
    this->mhIncome = mhIncome;
    this->numOfHH = numOfHH;

}

     */

    /*
    int EIN;
	string income;
	int incomeCode;
	long int income;
	string zip;
	string address;
	string state;
     */







    //NGO* hashTable[];


    //NGO* hashTable[tableSize];
   // NGO* hashTable = new NGO[realSize];

public:

    HashMap();
    HashMap(unsigned int tSize);
    unsigned int hashF(unsigned int key);
    void AddNGO(unsigned int income, vector<NGO> tempObj);
    int NumberOfNGOsInIndex(int index);
    void PrintTable();
    void PrintNGOsInIndex(int index); // all NGOs in specific bucket
    void Findname(unsigned int key);
    void reHash();
    void reHashh();

    //NGO NGOobj;

    NGO* hashTable[];


    //NGO* hashTable = new NGO[tableSize];




};



//const int HashMap::tableSize = 0;

void HashMap::AddNGO(unsigned int income, vector<NGO> tempObj){

    // here make sure to not include duplicates

    //hashTable[index].NGO;

    unsigned int index = hashF(income);

    if (hashTable[index]->NGOobj[0].income != income) { // testing to not include dups, works, but now include the values of the dups into the key.


        if (hashTable[index]->NGOobj[0].income == 0) // if table is empty
        {
            hashTable[index]->NGOobj[0].income = income;
            hashTable[index]->NGOobj[0].name = tempObj[0].name;
            // hashTable[index]->NGOobj[0].next = tempObj[0].next;
            hashTable[index]->NGOobj[0].EIN = tempObj[0].EIN;
            hashTable[index]->NGOobj[0].zip = tempObj[0].zip;
            hashTable[index]->NGOobj[0].address = tempObj[0].address;
            hashTable[index]->NGOobj[0].state = tempObj[0].state;
        }
        else // if table isn't empty
        {
            NGO *Ptr = hashTable[index];
            NGO *n = new NGO;
            n->income = income;
            n->name = tempObj[0].name;
            n->EIN = tempObj[0].EIN;
            n->zip = tempObj[0].zip;
            n->address = tempObj[0].address;
            n->state = tempObj[0].state;
            n->next = nullptr;
            while (Ptr->next != nullptr) {
                Ptr = Ptr->next;
            }
            Ptr->next = n;
        }
        elementCount++;
        cout << "element Count: " << elementCount << endl;
    }

    currLoadFactor = elementCount / tableSize;

    if (currLoadFactor >= maxLoadFactor){
        //  reHash();
    }
    cout << "currLoadFactor: " << currLoadFactor << endl;

}

/*
void HashMap::AddNGO(unsigned int income, string name){

    // here make sure to not include duplicates

    unsigned int index = hashF(income);

    if (hashTable[index]->income != income) { // testing to not include dups, works, but now include the values of the dups into the key.


        if (hashTable[index]->income == 0) // if table is empty
        {
            hashTable[index]->income = income;
            hashTable[index]->name = name;
        }
        else // if table isn't empty
        {
            NGO *Ptr = hashTable[index];
            NGO *n = new NGO;
            n->income = income;
            n->name = name;
            n->next = nullptr;
            while (Ptr->next != nullptr) {
                Ptr = Ptr->next;
            }
            Ptr->next = n;
        }
        elementCount++;
        cout << "element Count: " << elementCount << endl;
    }

    currLoadFactor = elementCount / tableSize;

    if (currLoadFactor >= maxLoadFactor){
      //  reHash();
    }
    cout << "currLoadFactor: " << currLoadFactor << endl;

}
*/
/*
 int *p = new int[5]; // locate memory in heap
    int *q = new int[10];// locate memory in heap

    for(int j=0; j<5;j++)
        p[j] = j;

    for(int i=0; i<5;i++)
        q[i] = p[i];

    delete []p;//Delete the old array 'p'
    p = q; // Assign the pointer of 'q' to 'p'
    q = NULL; // delete the location of pointer 'q'
 */

/*
void HashMap::reHashh(){
    NGO* tempMap = new NGO[tableSize * 2];
    for(int j=0; j<5;j++)
        p[j] = j;

    for(int i=0; i<5;i++)
        q[i] = p[i];


}
 */

/*
void HashMap::reHash() {
int OldCapacity = tableSize;
static const int tempSize = tableSize * 2 + 1;

NGO* newHT = new NGO[tempSize];


//fill in the new temp table with old info
    for (int i = 0; i < OldCapacity; ++i)
    {
        NGO *n = hashTable[i];
        while (n != nullptr)
        {
            // advance n *before* moving HashMap to new hash bed
            NGO *tmp = n;
            n = n->next;

            // find the proper collision list pointer.
            NGO*& bucket = newHT[hashF(tmp->income) % tempSize];
            tmp->next = bucket;
            bucket = tmp;
        }
    }

    delete [] *hashTable;
    hashTable = newHT;

}
 */


int HashMap::NumberOfNGOsInIndex(int index){
    int count = 0;

    if(hashTable[index]->income == 0){
        return count;
    }

    else {
        count++;
        NGO* Ptr = hashTable[index];
        while(Ptr->next != nullptr){
            count++;
            Ptr = Ptr->next;
        }
    }
    return count;
}


HashMap::HashMap(unsigned int tSize){
    tableSize = tSize;
    hashTable[tSize];

   // tableSize = tSize;
    int oldtsize = tableSize * 2;
    //tableSize = tSize;
    //HashMap** newHashTable = new HashMap*[tSize]();


    //NGO* hashTable[tSize];
    //hashTable = new(tSize);
    for (int i = 0; i < tableSize; i++) // changing tableSize to tSize
    {
        hashTable[i] = new NGO;
        hashTable[i]->NGOobj[0].income = 0;
        hashTable[i]->NGOobj[0].name = "empty";
        hashTable[i]->NGOobj[0].next = nullptr;
        hashTable[i]->NGOobj[0].EIN = 0;
        hashTable[i]->NGOobj[0].zip = "empty";
        hashTable[i]->NGOobj[0].address = "empty";
        hashTable[i]->NGOobj[0].state = "empty";

    }
}

void HashMap::PrintTable() {
    int number; // number of elements in each bucket
    for (int i = 0; i < tableSize; i++){ // changing tableSize to tSize
        number = NumberOfNGOsInIndex(i);// is gonna represent what bucket we're looking at
        if (number > 0) {
            cout << "-------------------" << endl;
            cout << "index = " << i << endl;
            cout << hashTable[i]->NGOobj[0].income << endl;
            cout << hashTable[i]->NGOobj[0].name << endl;
            cout << "# of NGOs = " << number << endl;
            cout << "-------------------" << endl;
        }
    }
}

void HashMap::PrintNGOsInIndex(int index){

    NGO* Ptr = hashTable[index]; // points to the first NGO in the bucket
    if(Ptr->income == 0){ // if nothing is here since default value is 0
        cout << "index = " << index << " is empty" << endl;
    }
    else {
        cout << "index " << index << " contains the following NGOs" << endl;

        while(Ptr != nullptr){
            cout << "--------------------" << endl;
            cout << Ptr->income << endl;
            cout << Ptr->name << endl;
            cout << "--------------------" << endl;
            Ptr = Ptr->next;
        }
    }
}

unsigned int HashMap::hashF(unsigned int key){




    unsigned int index = key % tableSize;
   // cout << index;
    return index;
}



void HashMap::Findname(unsigned int key) {
    int index = hashF(key);
    bool foundincome = false;

    string name;

    NGO* Ptr = hashTable[index]; // pointing to first NGO in the bucket
    while(Ptr != nullptr){
        if (Ptr->income == key){
            foundincome = true;
            name = Ptr->name;
        }
        Ptr = Ptr->next;
    }

    if (foundincome == true) { // can condense to just (foundincome)
        cout << "fav name: " << name << endl;
    }
    if (foundincome == false){
        cout << key << " income's info not found in hash table" << endl;
    }
}

int main() {

    // When printing map, make sure to not print stuff with 0 value.
    // unordered_map<income, vector<object>> resMap;
    HashMap Hashy(20); // calls default constructor
    NGO tempObj;
    vector<NGO> ngoVec;

    /*
     unsigned int income;
    string name;
    int EIN;
    string zip;
    string address;
    string state;
     */
    NGO tempObj2;
    vector<NGO> ngoVec2;

    NGO tempObj3;
    vector<NGO> ngoVec3;

    NGO tempObj4;
    vector<NGO> ngoVec4;

    tempObj.income = 542;
    tempObj.name = "fmirfmr";
    tempObj.EIN = 42;
    tempObj.zip = "ekefkf";
    tempObj.address = "ffkrfmrkn ktgtr";
    tempObj.state = "Wyoming";

    tempObj2.income = 546;
    tempObj2.name = "fmirfmr";
    tempObj2.EIN = 42;
    tempObj2.zip = "ekefkf";
    tempObj2.address = "ffkrfmrkn ktgtr";
    tempObj2.state = "Wyoming";

    tempObj3.income = 548;
    tempObj3.name = "fmirfmr";
    tempObj3.EIN = 42;
    tempObj3.zip = "ekefkf";
    tempObj3.address = "ffkrfmrkn ktgtr";
    tempObj3.state = "Wyoming";

    tempObj4.income = 504;
    tempObj4.name = "fmirfmr";
    tempObj4.EIN = 42;
    tempObj4.zip = "ekefkf";
    tempObj4.address = "ffkrfmrkn ktgtr";
    tempObj4.state = "Wyoming";

    ngoVec.push_back(tempObj);
    ngoVec2.push_back(tempObj2);
    ngoVec3.push_back(tempObj3);
    ngoVec4.push_back(tempObj4);


   // HashMap hashObj = *new HashMap(20);


    //car *p = new car("Honda", 2017);
    //newMap->elementCount = 0;


   // Hashy.PrintTable(); // should print 0 NGOs rn for testing

  // hashObj.AddNGO(14, "cocoa codld");

    Hashy.AddNGO(542, ngoVec); // yes
    Hashy.AddNGO(546, ngoVec2); // yes
    Hashy.AddNGO(548, ngoVec3); // yes
    Hashy.AddNGO(502, ngoVec4); //
    Hashy.AddNGO(502, ngoVec4); //

    Hashy.PrintTable();

  //  Hashy.PrintTable();

    //Hashy.PrintNGOsInIndex(17);

    // check if isDigit as well. Doesn't account for negative sign so issue there.
    /*
    while(key != -1){
        cout << "Search for ";
        cin >> key;

        if (key != -1 && isdigit(key)){
            Hashy.Findname(key);
        }
    }
    */


                            // 800,000
   // HashMap testHmap(800000);


   // testHmap.hashF(3500000001);
                        // 1,000,000
    // 1,234,567;  GoodWill




    return 0;
}


